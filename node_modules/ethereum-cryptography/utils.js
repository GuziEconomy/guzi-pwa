"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = exports.wrapHash = exports.assertBool = exports.assertBytes = exports.concatBytes = exports.equalsBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.hexToBytes = exports.createView = exports.toHex = void 0;
// buf.toString('hex') -> toHex(buf)
var utils_1 = require("noble-hashes/lib/utils");
Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return utils_1.bytesToHex; } });
Object.defineProperty(exports, "createView", { enumerable: true, get: function () { return utils_1.createView; } });
// Buffer.from(hex, 'hex') -> hexToBytes(hex)
function hexToBytes(hex) {
    if (typeof hex !== "string") {
        throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);
    }
    if (hex.length % 2) {
        throw new Error("hexToBytes: received invalid unpadded hex");
    }
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = Number.parseInt(hex.slice(j, j + 2), 16);
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// Buffer.from(s, 'utf8') -> utf8ToBytes(s)
function utf8ToBytes(s) {
    if (typeof s !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof s}`);
    }
    return new TextEncoder().encode(s);
}
exports.utf8ToBytes = utf8ToBytes;
// buf.toString('utf8') -> bytesToUtf8(buf)
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
exports.bytesToUtf8 = bytesToUtf8;
// buf.equals(buf2) -> equalsBytes(buf, buf2)
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.equalsBytes = equalsBytes;
// Buffer.concat([buf1, buf2]) -> concatBytes(buf1, buf2)
function concatBytes(...arrays) {
    if (arrays.length === 1) {
        return arrays[0];
    }
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// Internal utils
function assertBytes(bytes, ...len) {
    if (bytes instanceof Uint8Array &&
        (!len.length || len.includes(bytes.length))) {
        return;
    }
    throw new TypeError(`Expected ${len} bytes, not ${typeof bytes} with length=${bytes.length}`);
}
exports.assertBytes = assertBytes;
function assertBool(b) {
    if (typeof b !== "boolean") {
        throw new Error(`Expected boolean, not ${b}`);
    }
}
exports.assertBool = assertBool;
function wrapHash(hash) {
    return (msg) => {
        assertBytes(msg);
        return hash(msg);
    };
}
exports.wrapHash = wrapHash;
exports.crypto = (() => {
    const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : undefined;
    const nodeRequire = typeof module !== "undefined" &&
        typeof module.require === "function" &&
        module.require.bind(module);
    return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
        web: webCrypto
    };
})();
//# sourceMappingURL=utils.js.map