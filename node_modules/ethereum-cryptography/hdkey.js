"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKey = void 0;
const micro_base_1 = require("micro-base");
const hmac_1 = require("noble-hashes/lib/hmac");
const ripemd160_1 = require("noble-hashes/lib/ripemd160");
const sha256_1 = require("noble-hashes/lib/sha256");
const sha512_1 = require("noble-hashes/lib/sha512");
const utils_1 = require("noble-hashes/lib/utils");
const secp = __importStar(require("./secp256k1"));
const utils_2 = require("./utils");
const base58c = (0, micro_base_1.base58check)(sha256_1.sha256);
function bytesToNumber(bytes) {
    return BigInt(`0x${(0, utils_1.bytesToHex)(bytes)}`);
}
function numberToBytes(num) {
    return (0, utils_2.hexToBytes)(num.toString(16).padStart(64, "0"));
}
function modN(a, b = secp.CURVE.n) {
    const result = a % b;
    return result >= 0 ? result : b + result;
}
const MASTER_SECRET = (0, utils_2.utf8ToBytes)("Bitcoin seed");
// Bitcoin hardcoded by default
const BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };
const hash160 = (data) => (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(data));
const fromU32 = (data) => (0, utils_2.createView)(data).getUint32(0, false);
const toU32 = (n) => {
    const buf = new Uint8Array(4);
    (0, utils_2.createView)(buf).setUint32(0, n, false);
    return buf;
};
class HDKey {
    constructor(versions) {
        this.depth = 0;
        this.index = 0;
        this.chainCode = null;
        this.parentFingerprint = 0;
        this.versions = versions || BITCOIN_VERSIONS;
    }
    static fromMasterSeed(seed, versions) {
        const I = (0, hmac_1.hmac)(sha512_1.sha512, MASTER_SECRET, seed);
        const hdkey = new HDKey(versions);
        hdkey.chainCode = I.slice(32);
        hdkey.privateKey = I.slice(0, 32);
        return hdkey;
    }
    static fromExtendedKey(base58key, versions) {
        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
        const hdkey = new HDKey(versions);
        const keyBuffer = base58c.decode(base58key);
        const keyView = (0, utils_2.createView)(keyBuffer);
        const version = keyView.getUint32(0, false);
        hdkey.depth = keyBuffer[4];
        hdkey.parentFingerprint = keyView.getUint32(5, false);
        hdkey.index = keyView.getUint32(9, false);
        hdkey.chainCode = keyBuffer.slice(13, 45);
        const key = keyBuffer.slice(45);
        const isPriv = key[0] === 0;
        if (version !== hdkey.versions[isPriv ? "private" : "public"]) {
            throw new Error("Version mismatch");
        }
        if (isPriv) {
            hdkey.privateKey = key.slice(1);
        }
        else {
            hdkey.publicKey = key;
        }
        return hdkey;
    }
    static fromJSON(json) {
        return HDKey.fromExtendedKey(json.xpriv);
    }
    get fingerprint() {
        if (!this.pubHash) {
            throw new Error("No publicKey set!");
        }
        return fromU32(this.pubHash);
    }
    get identifier() {
        return this.pubHash;
    }
    get pubKeyHash() {
        return this.pubHash;
    }
    get privateKey() {
        return this.privKeyBytes || null;
    }
    set privateKey(value) {
        if (value == null) {
            this.wipePrivateData();
            return;
        }
        if (!secp.utils.isValidPrivateKey(value)) {
            throw new Error("Invalid private key");
        }
        this.privKey = typeof value === "bigint" ? value : bytesToNumber(value);
        this.privKeyBytes = numberToBytes(this.privKey);
        this.pubKey = secp.getPublicKey(value, true);
        this.pubHash = hash160(this.pubKey);
    }
    get publicKey() {
        return this.pubKey || null;
    }
    set publicKey(value) {
        let hex;
        try {
            hex = secp.Point.fromHex(value);
        }
        catch (error) {
            throw new Error("Invalid public key");
        }
        this.pubKey = hex.toRawBytes(true); // force compressed point
        this.pubHash = hash160(this.pubKey);
        this.privKey = undefined;
    }
    get privateExtendedKey() {
        const priv = this.privateKey;
        if (!priv) {
            throw new Error("No private key");
        }
        return base58c.encode(this.serialize(this.versions.private, (0, utils_2.concatBytes)(new Uint8Array([0]), priv)));
    }
    get publicExtendedKey() {
        if (!this.pubKey) {
            throw new Error("No public key");
        }
        return base58c.encode(this.serialize(this.versions.public, this.pubKey));
    }
    derive(path) {
        if (!/^[mM]'?/.test(path)) {
            throw new Error('Path must start with "m" or "M"');
        }
        if (/^[mM]'?$/.test(path)) {
            return this;
        }
        const parts = path.replace(/^[mM]'?\//, "").split("/");
        // tslint:disable-next-line
        let child = this;
        for (const c of parts) {
            const m = /^(\d+)('?)$/.exec(c);
            if (!m || m.length !== 3) {
                throw new Error(`Invalid child index: ${c}`);
            }
            let idx = +m[1];
            if (!Number.isSafeInteger(idx) || idx >= HDKey.HARDENED_OFFSET) {
                throw new Error("Invalid index");
            }
            // hardened key
            if (m[2] === "'") {
                idx += HDKey.HARDENED_OFFSET;
            }
            child = child.deriveChild(idx);
        }
        return child;
    }
    deriveChild(index) {
        if (!Number.isSafeInteger(index) || index < 0 || index >= 2 ** 33) {
            throw new Error(`Child index should be positive 32-bit integer, not ${index}`);
        }
        if (!this.pubKey || !this.chainCode) {
            throw new Error("No publicKey or chainCode set");
        }
        let data = new Uint8Array(4);
        (0, utils_2.createView)(data).setUint32(0, index, false);
        if (index >= HDKey.HARDENED_OFFSET) {
            // Hardened
            const priv = this.privateKey;
            if (!priv) {
                throw new Error("Could not derive hardened child key");
            }
            // Hardened child: 0x00 || ser256(kpar) || ser32(index)
            data = (0, utils_2.concatBytes)(new Uint8Array([0]), priv, data);
        }
        else {
            // Normal child: serP(point(kpar)) || ser32(index)
            data = (0, utils_2.concatBytes)(this.pubKey, data);
        }
        const I = (0, hmac_1.hmac)(sha512_1.sha512, this.chainCode, data);
        const childTweak = bytesToNumber(I.slice(0, 32));
        const chainCode = I.slice(32);
        if (!secp.utils.isValidPrivateKey(childTweak)) {
            throw new Error("Tweak bigger than curve order");
        }
        const child = new HDKey(this.versions);
        try {
            // Private parent key -> private child key
            if (this.privateKey) {
                const added = modN(this.privKey + childTweak);
                if (!secp.utils.isValidPrivateKey(added)) {
                    throw new Error("The tweak was out of range or the resulted private key is invalid");
                }
                child.privateKey = added;
            }
            else {
                child.publicKey = secp.Point.fromHex(this.pubKey)
                    .add(secp.Point.fromPrivateKey(childTweak))
                    .toRawBytes(true);
            }
        }
        catch (err) {
            return this.deriveChild(index + 1);
        }
        child.chainCode = chainCode;
        child.depth = this.depth + 1;
        child.parentFingerprint = this.fingerprint;
        child.index = index;
        return child;
    }
    sign(hash) {
        if (!this.privateKey) {
            throw new Error("No privateKey set!");
        }
        (0, utils_2.assertBytes)(hash, 32);
        return secp.signSync(hash, this.privKey, { canonical: true, der: false });
    }
    verify(hash, signature) {
        (0, utils_2.assertBytes)(hash, 32);
        (0, utils_2.assertBytes)(signature, 64);
        if (!this.publicKey) {
            throw new Error("No publicKey set!");
        }
        let sig;
        try {
            sig = secp.Signature.fromCompact(signature);
        }
        catch (error) {
            return false;
        }
        return secp.verify(sig, hash, this.publicKey);
    }
    wipePrivateData() {
        if (this.privKey) {
            this.privKey = undefined;
            this.privKeyBytes.fill(0);
            this.privKeyBytes = undefined;
        }
        this.privKey = undefined;
        return this;
    }
    toJSON() {
        return {
            xpriv: this.privateExtendedKey,
            xpub: this.publicExtendedKey
        };
    }
    serialize(version, key) {
        if (!this.chainCode) {
            throw new Error("No chainCode set");
        }
        (0, utils_2.assertBytes)(key, 33);
        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
        return (0, utils_2.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
    }
}
exports.HDKey = HDKey;
HDKey.HARDENED_OFFSET = 0x80000000;
//# sourceMappingURL=hdkey.js.map